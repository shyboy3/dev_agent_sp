def is_decorative_image(path: str) -> bool:
    """로고/아이콘처럼 너무 작은/띠 모양 이미지는 True로 반환."""
    try:
        with PILImage.open(path) as im:
            w, h = im.size
    except Exception:
        return False  # 열 수 없으면 필터링하지 않음

    area = w * h

    # (1) 너무 작은 건 장식용으로 간주 (예: 200x100 이하면)
    if area < 50_000:  # 필요하면 숫자 조정 가능
        return True

    # (2) 가로로만 긴 배너, 세로로만 긴 띠 (ex: 로고/헤더)
    ratio = max(w, h) / max(1, min(w, h))
    if ratio > 5:  # 5배 이상 길쭉하면 장식으로 봄
        return True

    return False





figs = []
for item in parsed_files:
    imgs = item.get("extracted_images") or []
    if not imgs:
        continue
    for path in imgs:
        if not path or not os.path.exists(path):
            continue
        # ★ 장식용 이미지면 스킵
        if is_decorative_image(path):
            continue
        figs.append((item.get("filename","unnamed"), path))




# Java 11+ 설치 (이미 있으면 패스)
# Windows면 Adoptium Temurin 같은 JDK 설치 후 PATH 잡기

pip install -U opendataloader-pdf




import os, io, json
import fitz  # PyMuPDF
from PIL import Image as PILImage

try:
    import opendataloader_pdf
    _HAS_ODL = True
except ImportError:
    _HAS_ODL = False








def _extract_images_from_pdf(raw: bytes, filename: str, tmp_dir: str):
    """PyMuPDF로 embedded 이미지 + 페이지 전체 캡처를 PNG로 추출."""
    base_name = os.path.splitext(filename)[0]
    images = []

    with fitz.open(stream=raw, filetype="pdf") as doc:
        for pno in range(len(doc)):
            page = doc[pno]

            # embedded 이미지
            for img in page.get_images(full=True):
                xref = img[0]
                pix = fitz.Pixmap(doc, xref)
                if pix.alpha:
                    pix = fitz.Pixmap(fitz.csRGB, pix)
                ipath = os.path.join(
                    tmp_dir,
                    f"{base_name}_p{pno+1}_img{xref}.png"
                )
                pix.save(ipath)
                images.append(ipath)

            # 페이지 전체 캡처
            try:
                pix_page = page.get_pixmap(dpi=200)
                ppath = os.path.join(
                    tmp_dir,
                    f"{base_name}_page{pno+1}_full.png"
                )
                pix_page.save(ppath)
                images.append(ppath)
            except Exception:
                pass

    return images







def parse_pdf_local(raw: bytes, filename: str, tmp_dir: str):
    """
    - 텍스트/레이아웃: OpenDataLoader-PDF(JSON) 사용
    - 이미지: PyMuPDF로 추출
    """
    base_name = os.path.splitext(filename)[0]

    # 1) 텍스트/레이아웃: OpenDataLoader-PDF
    text_chunks = []

    if _HAS_ODL:
        # raw bytes를 임시 파일로 저장 (ODL은 경로 기반)
        tmp_pdf = os.path.join(tmp_dir, f"odl_{base_name}.pdf")
        with open(tmp_pdf, "wb") as f:
            f.write(raw)

        try:
            # JSON 출력 생성
            opendataloader_pdf.convert(
                input_path=[tmp_pdf],
                output_dir=tmp_dir,
                format=["json"],
                quiet=True,
            )
            json_path = os.path.join(tmp_dir, f"{os.path.basename(tmp_pdf)}.json")
            # 실제 생성 파일 이름이 원본 basename 기준일 수 있어서 fallback
            if not os.path.exists(json_path):
                alt = os.path.join(tmp_dir, f"{base_name}.json")
                if os.path.exists(alt):
                    json_path = alt

            if os.path.exists(json_path):
                with open(json_path, "r", encoding="utf-8") as jf:
                    data = json.load(jf)

                # JSON 트리에서 텍스트를 쭉 모으는 헬퍼
                collected = []

                def _walk(node):
                    if isinstance(node, dict):
                        txt = node.get("text")
                        if txt:
                            collected.append(txt)
                        kids = node.get("kids") or node.get("children") or []
                        for k in kids:
                            _walk(k)
                    elif isinstance(node, list):
                        for k in node:
                            _walk(k)

                _walk(data)

                # 너무 잘게 쪼개지지 않게, 적당히 묶어서 chunk 생성
                if collected:
                    big_text = "\n".join(collected)
                    # 문단 단위로 쪼개기
                    paras = [p.strip() for p in big_text.split("\n\n") if p.strip()]
                    chunk = []
                    cur_len = 0
                    for p in paras:
                        if cur_len + len(p) > 3000 and chunk:
                            text_chunks.append("\n\n".join(chunk))
                            chunk = [p]
                            cur_len = len(p)
                        else:
                            chunk.append(p)
                            cur_len += len(p)
                    if chunk:
                        text_chunks.append("\n\n".join(chunk))
        except Exception as e:
            # ODL 실패 시 fallback으로 내려감
            print(f"[WARN] OpenDataLoader PDF 실패: {e}")

    # 2) fallback: OpenDataLoader가 없거나/실패했을 때 PyMuPDF로 텍스트만 뽑기
    if not text_chunks:
        with fitz.open(stream=raw, filetype="pdf") as doc:
            for pno in range(len(doc)):
                page = doc[pno]
                txt = page.get_text("text")
                if txt and txt.strip():
                    text_chunks.append(f"[Page {pno+1}]\n{txt.strip()}")

    # 3) 이미지 추출 (PyMuPDF)
    images = _extract_images_from_pdf(raw, filename, tmp_dir)

    return {
        "type": "pdf_doc",
        "filename": filename,
        "text_chunks": text_chunks[:120],  # 필요하면 조절
        "extracted_images": images,
    }






elif name.endswith(".pdf"):
    parsed_files.append(parse_pdf_local(raw, os.path.basename(full_path), tmp_dir))




