research_report_server_web.py:

import os
import io
import json
import tempfile
from typing import List, Optional

import pandas as pd
from fastapi import FastAPI, UploadFile, File, Form, Request
from fastapi.responses import FileResponse, HTMLResponse, Response
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel

from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet

import pytesseract
from PIL import Image
import httpx

# =========================
# ì„¤ì •
# =========================

LLM_API_URL = "http://localhost:11434/api/generate"    # ë¡œì»¬ LLM API (Ollama ì˜ˆì‹œ)
LLM_MODEL = "qwen2.5-7b-instruct"                      # ì‹¤ì œ ì„¤ì¹˜í•œ ëª¨ë¸ ì´ë¦„

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
STATIC_DIR = os.path.join(BASE_DIR, "static")

app = FastAPI(title="Research Report Generator")

# ì •ì  íŒŒì¼ (index.html, css, js) ì„œë¹™
if not os.path.exists(STATIC_DIR):
    os.makedirs(STATIC_DIR)

app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")


# =========================
# ìœ í‹¸: LLM í˜¸ì¶œ
# =========================

async def call_llm(prompt: str, system_prompt: str = "") -> str:
    payload = {
        "model": LLM_MODEL,
        "prompt": (system_prompt + "\n\n" + prompt).strip(),
        "stream": False,
    }
    async with httpx.AsyncClient(timeout=600) as client:
        r = await client.post(LLM_API_URL, json=payload)
        r.raise_for_status()
        data = r.json()
        # Ollama ê¸°ì¤€: {"model":..., "created_at":..., "response":"..."}
        return data.get("response", "")


# =========================
# ë©”íƒ€ë°ì´í„° ëª¨ë¸
# =========================

class ReportMeta(BaseModel):
    project_name: Optional[str] = None
    sample_id: Optional[str] = None
    sample_description: Optional[str] = None
    operator: Optional[str] = None
    date: Optional[str] = None
    techniques: Optional[List[str]] = None
    key_questions: Optional[str] = None


# =========================
# íŒŒì¼ íŒŒì„œ
# =========================

def parse_txt(raw: bytes, filename: str):
    text = raw.decode("utf-8", errors="ignore")
    return {
        "type": "note",
        "filename": filename,
        "text": text
    }

def parse_csv(raw: bytes, filename: str):
    df = pd.read_csv(io.BytesIO(raw))

    numeric_cols = df.select_dtypes(include="number").columns.tolist()

    profile = {
        "rows": int(len(df)),
        "cols": int(len(df.columns)),
        "columns": [str(c) for c in df.columns]
    }

    stats = {}
    if numeric_cols:
        desc = df[numeric_cols].describe().to_dict()
        # JSON ì§ë ¬í™”ìš© float ë³€í™˜
        stats = {col: {k: float(v) for k, v in m.items()} for col, m in desc.items()}

    sample_rows = df.head(20).to_dict(orient="records")

    return {
        "type": "csv_result",
        "filename": filename,
        "profile": profile,
        "stats": stats,
        "sample_rows": sample_rows
    }

def parse_image(raw: bytes, filename: str):
    img = Image.open(io.BytesIO(raw))
    try:
        ocr = pytesseract.image_to_string(img, lang="eng+kor")
    except Exception:
        ocr = ""
    return {
        "type": "image_result",
        "filename": filename,
        "ocr_hint": ocr.strip(),
        "comment": "Microscopy or measurement image; use for morphology/defect/phase discussion."
    }

def parse_other(raw: bytes, filename: str):
    return {
        "type": "other_file",
        "filename": filename,
        "comment": "Unsupported file type; mention only as supplemental data if needed."
    }


# =========================
# ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ (ì—°êµ¬ ë¦¬í¬íŠ¸ ëª¨ë“œ)
# =========================

SYSTEM_PROMPT = """
ë‹¹ì‹ ì€ ì¬ë£Œ/ì†Œì/ë‚˜ë…¸êµ¬ì¡° ë¶„ì„ì„ ì „ë¬¸ìœ¼ë¡œ í•˜ëŠ” ì—°êµ¬ ë¦¬í¬íŠ¸ ì‘ì„±ìì…ë‹ˆë‹¤.
ì…ë ¥ ìë£Œë¥¼ ê¸°ë°˜ìœ¼ë¡œ 'ì‹œë£Œ ë¶„ì„ ê²°ê³¼ ë³´ê³ ì„œ' ì´ˆì•ˆì„ ì‘ì„±í•©ë‹ˆë‹¤.

ê·œì¹™:
1. êµ¬ì¡° (í•œêµ­ì–´, ë§ˆí¬ë‹¤ìš´ í—¤ë”© ì‚¬ìš© ê°€ëŠ¥):
# [Report Title]
## 1. Introduction & Objective
## 2. Sample Information
## 3. Experimental Methods
## 4. Results
## 5. Discussion
## 6. Conclusion
## 7. Suggestions / Future Work
(ì„ íƒ) ## Appendix (í•µì‹¬ íŒŒë¼ë¯¸í„°/ê°„ë‹¨ í‘œë§Œ)

2. ìŠ¤íƒ€ì¼:
- ë…¼ë¬¸/í…Œí¬ë‹ˆì»¬ ë¦¬í¬íŠ¸ í†¤.
- ê³¼ì¥ ì—†ì´: "ê´€ì°°ëœë‹¤", "ì‹œì‚¬í•œë‹¤", "ê°€ëŠ¥ì„±ì´ ìˆë‹¤", "ë°ì´í„° ë²”ìœ„ ë‚´ì—ì„œ" ë“± ì‚¬ìš©.
- ì¸ê³¼ê´€ê³„ëŠ” ì„£ë¶ˆë¦¬ ë‹¨ì •í•˜ì§€ ì•ŠëŠ”ë‹¤.

3. ë°ì´í„° ì‚¬ìš©:
- ì—…ë¡œë“œëœ txt/csv/image ë‚´ìš©ì€ ì°¸ê³ ìš©.
- ìµœì¢… ê²°ê³¼ì—ëŠ” raw ë°ì´í„° ì „ì²´ë¥¼ ë³µë¶™í•˜ì§€ ë§ ê²ƒ.
- ëŒ€ì‹ :
  - ì£¼ìš” í”¼í¬/íŠ¹ì§•/ìƒ(phase)/ì¡°ì„±/ë‘ê»˜/ì…ë„/ê²°í•¨/ê³„ë©´ íŠ¹ì„±
  - ê³µì • ì¡°ê±´ê³¼ íŠ¹ì„± ê°„ì˜ ê²½í–¥
  ë¥¼ ìš”ì•½í•´ì„œ ê¸°ìˆ .

4. ì´ë¯¸ì§€:
- ì´ë¯¸ì§€ê°€ ìˆë‹¤ë©´ "ê·¸ë¦¼ 1", "ê·¸ë¦¼ 2" ë“±ìœ¼ë¡œ ì–¸ê¸‰.
- ê°€ëŠ¥í•œ ë²”ìœ„ì—ì„œ í˜•ìƒ/ê· ì¼ì„±/ê²°í•¨/ê³„ë©´ ìƒíƒœ ë“±ì„ ì„¤ëª…í•˜ë˜, ì œê³µ ì •ë³´ ì´ìƒ ì¶”ì¸¡ ê¸ˆì§€.

5. ë©”íƒ€ë°ì´í„°:
- project_name, sample_id, techniques, key_questionsê°€ ìˆìœ¼ë©´
  ì œëª©, ì„œë¡ , Discussion/Conclusionì— ìì—°ìŠ¤ëŸ½ê²Œ ë°˜ì˜.
"""


# =========================
# ì»¨í…ìŠ¤íŠ¸ & ë¦¬í¬íŠ¸ ìƒì„±
# =========================

def build_context(meta: ReportMeta, parsed_files):
    return {
        "meta": meta.dict(),
        "files": parsed_files
    }

async def generate_report_text(meta: ReportMeta, parsed_files) -> str:
    context = build_context(meta, parsed_files)

    prompt = f"""
ë‹¤ìŒì€ ì‹œë£Œ ë¶„ì„ í”„ë¡œì íŠ¸ì˜ ë©”íƒ€ë°ì´í„°ì™€ ë¶„ì„ ê²°ê³¼ ìš”ì•½ì…ë‹ˆë‹¤.
ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìœ„ ê·œì¹™ì— ë§ëŠ” 'ì‹œë£Œ ë¶„ì„ ê²°ê³¼ ë³´ê³ ì„œ'ë¥¼ ì‘ì„±í•˜ì„¸ìš”.

[ë©”íƒ€ë°ì´í„° ë° íŒŒì¼ ìš”ì•½]
{json.dumps(context, ensure_ascii=False)}

ìš”êµ¬ì‚¬í•­:
- ì œì‹œëœ êµ¬ì¡°ë¥¼ ë”°ë¥´ë˜, ë‚´ìš©ì´ ë¶€ì¡±í•œ ì„¹ì…˜ì€ ê°„ë‹¨íˆ ê¸°ìˆ .
- key_questionsê°€ ìˆë‹¤ë©´ Results/Discussion/Conclusionì—ì„œ ì§ì ‘ì ìœ¼ë¡œ ë‹¤ë£¨ì„¸ìš”.
- techniques ì •ë³´ì— ë§ëŠ” í˜„ì‹¤ì ì¸ í•´ì„ë§Œ ì‚¬ìš©í•˜ì„¸ìš”.
"""
    return await call_llm(prompt, SYSTEM_PROMPT)


# =========================
# PDF ë Œë”ë§
# =========================

def render_pdf(report_text: str) -> bytes:
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4)
    styles = getSampleStyleSheet()
    story = []

    for line in report_text.splitlines():
        t = line.strip()
        if not t:
            story.append(Spacer(1, 6))
            continue
        if t.startswith("# "):
            story.append(Paragraph(f"<b>{t[2:]}</b>", styles["Heading1"]))
        elif t.startswith("## "):
            story.append(Paragraph(f"<b>{t[3:]}</b>", styles["Heading2"]))
        elif t.startswith("### "):
            story.append(Paragraph(f"<b>{t[4:]}</b>", styles["Heading3"]))
        else:
            story.append(Paragraph(t, styles["BodyText"]))
        story.append(Spacer(1, 4))

    doc.build(story)
    pdf_data = buffer.getvalue()
    buffer.close()
    return pdf_data


# =========================
# HTML UI: ë©”ì¸ í˜ì´ì§€
# =========================

@app.get("/", response_class=HTMLResponse)
async def index():
    # static/index.htmlì„ ì„œë¹™
    index_path = os.path.join(STATIC_DIR, "index.html")
    if os.path.exists(index_path):
        with open(index_path, "r", encoding="utf-8") as f:
            return HTMLResponse(f.read())
    # ì—†ìœ¼ë©´ ê°„ë‹¨í•œ ì•ˆë‚´
    return HTMLResponse("<h1>Research Report Generator</h1><p>index.htmlì´ ì—†ìŠµë‹ˆë‹¤.</p>")


# =========================
# PDF ìƒì„± API (í”„ë¡ íŠ¸ì—ì„œ í˜¸ì¶œ)
# =========================

@app.post("/api/generate-research-report")
async def api_generate_research_report(
    project_name: str = Form(""),
    sample_id: str = Form(""),
    sample_description: str = Form(""),
    operator: str = Form(""),
    date: str = Form(""),
    techniques: str = Form(""),  # "TEM,EELS,XRD"
    key_questions: str = Form(""),
    files: List[UploadFile] = File(...)
):
    # techniques íŒŒì‹±
    tech_list = [t.strip() for t in techniques.split(",") if t.strip()] if techniques else []

    meta = ReportMeta(
        project_name=project_name or None,
        sample_id=sample_id or None,
        sample_description=sample_description or None,
        operator=operator or None,
        date=date or None,
        techniques=tech_list or None,
        key_questions=key_questions or None,
    )

    parsed_files = []
    for f in files:
        raw = await f.read()
        name = f.filename.lower()
        if name.endswith(".txt"):
            parsed_files.append(parse_txt(raw, f.filename))
        elif name.endswith(".csv"):
            parsed_files.append(parse_csv(raw, f.filename))
        elif name.endswith((".png", ".jpg", ".jpeg", ".tif", ".tiff")):
            parsed_files.append(parse_image(raw, f.filename))
        else:
            parsed_files.append(parse_other(raw, f.filename))

    report_text = await generate_report_text(meta, parsed_files)
    pdf_bytes = render_pdf(report_text)

    # ë¸Œë¼ìš°ì €ì—ì„œ ì§ì ‘ ë°›ê¸° ì¢‹ê²Œ application/pdfë¡œ ë°˜í™˜
    headers = {
        "Content-Disposition": 'inline; filename="research_report.pdf"'
    }
    return Response(content=pdf_bytes, media_type="application/pdf", headers=headers)


static/index.html (ìµœì†Œ ë™ì‘ ë²„ì „, ë°”ë¡œ ì‚¬ìš© ê°€ëŠ¥):

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì—°êµ¬ ì‹œë£Œ ë¶„ì„ ë¦¬í¬íŠ¸ ìƒì„±ê¸°</title>
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; margin: 20px; }
    h1 { margin-bottom: 4px; }
    .subtitle { color: #666; margin-bottom: 20px; }
    .section { margin-bottom: 16px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; }
    .section h2 { margin: 0 0 8px; font-size: 16px; }
    label { display: block; margin-top: 6px; font-size: 13px; }
    input[type="text"], input[type="date"], textarea {
      width: 100%; padding: 6px 8px; margin-top: 2px;
      box-sizing: border-box; font-size: 13px;
    }
    textarea { resize: vertical; min-height: 60px; }
    .chips label { display: inline-flex; align-items: center; margin-right: 8px; margin-top: 4px; }
    .chips input { margin-right: 4px; }
    .file-box { padding: 8px; background:#fafafa; border-radius:6px; border:1px dashed #bbb; }
    button {
      margin-top: 10px; padding: 10px 18px; font-size: 14px;
      border: none; border-radius: 6px; cursor: pointer;
      background: #2563eb; color: #fff;
    }
    button:disabled { opacity: 0.6; cursor: default; }
    #status { margin-top: 10px; font-size: 13px; color: #444; }
    #pdf-container { margin-top: 20px; }
    #pdf-frame { width: 100%; height: 600px; border: 1px solid #ccc; border-radius: 6px; }
    #download-link { display: inline-block; margin-top: 8px; font-size: 13px; }
  </style>
</head>
<body>
  <h1>ì—°êµ¬ ì‹œë£Œ ë¶„ì„ ë¦¬í¬íŠ¸ ìƒì„±ê¸°</h1>
  <div class="subtitle">
    ì‹œë£Œ ê´€ë ¨ ë©”íƒ€ë°ì´í„°ì™€ ë¶„ì„ ê²°ê³¼ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´,<br>
    ë¡œì»¬ LLMì´ ìë™ìœ¼ë¡œ ì—°êµ¬ìš© ë¦¬í¬íŠ¸ ì´ˆì•ˆì„ ìƒì„±í•©ë‹ˆë‹¤.
  </div>

  <form id="report-form">
    <div class="section">
      <h2>ê¸°ë³¸ ì •ë³´</h2>
      <label>Project Name
        <input type="text" name="project_name" placeholder="ì˜ˆ: Hf-ZrO2 Gate Stack Reliability Study" />
      </label>
      <label>Sample ID
        <input type="text" name="sample_id" placeholder="ì˜ˆ: HZ-ALD-230901-03" />
      </label>
      <label>Sample Description
        <textarea name="sample_description" placeholder="ì‹œë£Œ êµ¬ì¡°, ê³µì • ì¡°ê±´, ìŠ¤íƒ ì •ë³´ ë“±ì„ ê°„ë‹¨íˆ ê¸°ì…"></textarea>
      </label>
      <label>Operator / Author
        <input type="text" name="operator" placeholder="ì‘ì„±ì ì´ë¦„" />
      </label>
      <label>Date
        <input type="date" name="date" />
      </label>
    </div>

    <div class="section">
      <h2>ë¶„ì„ ê¸°ë²•</h2>
      <div class="chips">
        <label><input type="checkbox" value="TEM"> TEM</label>
        <label><input type="checkbox" value="STEM"> STEM</label>
        <label><input type="checkbox" value="SEM"> SEM</label>
        <label><input type="checkbox" value="EDS"> EDS</label>
        <label><input type="checkbox" value="EELS"> EELS</label>
        <label><input type="checkbox" value="XRD"> XRD</label>
        <label><input type="checkbox" value="XPS"> XPS</label>
        <label><input type="checkbox" value="AFM"> AFM</label>
        <label><input type="checkbox" value="Raman"> Raman</label>
        <label><input type="checkbox" value="PL"> PL</label>
        <label><input type="checkbox" value="IV"> IV/CV</label>
      </div>
    </div>

    <div class="section">
      <h2>í•µì‹¬ ì§ˆë¬¸ / ë¶„ì„ ëª©ì </h2>
      <textarea name="key_questions"
        placeholder="ì˜ˆ: ferroelectric phase fraction í‰ê°€, interface roughness ë° diffusion ì—¬ë¶€, oxygen vacancy ë¶„í¬, leakage ê´€ë ¨ ê²°í•¨ ìœ ë¬´ ë“±"></textarea>
    </div>

    <div class="section">
      <h2>ë°ì´í„° ì—…ë¡œë“œ</h2>
      <div class="file-box">
        <p style="margin:0 0 4px; font-size:12px;">
          ì§€ì›: csv (ìˆ˜ì¹˜ ê²°ê³¼), txt (ë…¸íŠ¸/ë¡œê·¸), png/jpg/tif (ì´ë¯¸ì§€), ê¸°íƒ€ íŒŒì¼ì€ ì°¸ê³ ìš©ìœ¼ë¡œë§Œ í‘œì‹œë©ë‹ˆë‹¤.
        </p>
        <input type="file" id="files" name="files" multiple />
      </div>
    </div>

    <button type="submit" id="submit-btn">ë¦¬í¬íŠ¸ ìƒì„±</button>
    <div id="status"></div>
  </form>

  <div id="pdf-container" style="display:none;">
    <h2>ìƒì„±ëœ ë¦¬í¬íŠ¸</h2>
    <iframe id="pdf-frame"></iframe>
    <a id="download-link" href="#" download="research_report.pdf">ğŸ“¥ PDF ë‹¤ìš´ë¡œë“œ</a>
  </div>

  <script>
    const form = document.getElementById('report-form');
    const statusEl = document.getElementById('status');
    const submitBtn = document.getElementById('submit-btn');
    const pdfContainer = document.getElementById('pdf-container');
    const pdfFrame = document.getElementById('pdf-frame');
    const downloadLink = document.getElementById('download-link');

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      statusEl.textContent = "ë¦¬í¬íŠ¸ë¥¼ ìƒì„± ì¤‘ì…ë‹ˆë‹¤. (ë¡œì»¬ LLM ì²˜ë¦¬)";
      submitBtn.disabled = true;
      pdfContainer.style.display = 'none';

      const fd = new FormData();

      // ê¸°ë³¸ í•„ë“œ
      fd.append('project_name', form.project_name.value);
      fd.append('sample_id', form.sample_id.value);
      fd.append('sample_description', form.sample_description.value);
      fd.append('operator', form.operator.value);
      fd.append('date', form.date.value);

      // techniques ì²´í¬ë°•ìŠ¤ â†’ "TEM,EELS,XRD" í˜•íƒœ ë¬¸ìì—´
      const techs = [];
      form.querySelectorAll('.chips input[type="checkbox"]:checked').forEach(chk => {
        techs.push(chk.value);
      });
      fd.append('techniques', techs.join(','));

      // key_questions
      fd.append('key_questions', form.key_questions.value);

      // íŒŒì¼ë“¤
      const filesInput = document.getElementById('files');
      if (filesInput.files.length === 0) {
        statusEl.textContent = "âš  ë°ì´í„° íŒŒì¼ì„ í•œ ê°œ ì´ìƒ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.";
        submitBtn.disabled = false;
        return;
      }
      for (const file of filesInput.files) {
        fd.append('files', file);
      }

      try {
        const res = await fetch('/api/generate-research-report', {
          method: 'POST',
          body: fd
        });

        if (!res.ok) {
          throw new Error('ì„œë²„ ì˜¤ë¥˜: ' + res.status);
        }

        const blob = await res.blob();
        const url = URL.createObjectURL(blob);

        // PDF iframeì— í‘œì‹œ
        pdfFrame.src = url;
        // ë‹¤ìš´ë¡œë“œ ë§í¬ ì„¤ì •
        downloadLink.href = url;
        downloadLink.download = "research_report.pdf";

        pdfContainer.style.display = 'block';
        statusEl.textContent = "âœ… ë¦¬í¬íŠ¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "âŒ ë¦¬í¬íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + err.message;
      } finally {
        submitBtn.disabled = false;
      }
    });
  </script>
</body>
</html>




