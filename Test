#Functions
import base64, json, httpx

async def analyze_figure_image(
    image_path: str,
    backend: str,
    api_url: str,
    model_name: str,
    api_key: str | None = None,
) -> dict | None:
    """
    그림 1장의 의미를 분석해서 공통 FigureAnalysis dict로 돌려준다.
    backend 값에 따라 Qwen / 다른 모델 분기.
    """
    if backend == "qwen":
        return await _analyze_with_qwen(image_path, api_url, model_name, api_key)
    elif backend == "openai":
        return await _analyze_with_openai(image_path, api_url, model_name, api_key)
    # elif backend == "ollama": ...
    else:
        return None







FIGURE_PROMPT = """... (아까 만든 JSON만 출력하라는 프롬프트) ..."""

async def _analyze_with_qwen(image_path: str, api_url: str, model_name: str, api_key: str | None):
    try:
        with open(image_path, "rb") as f:
            b = f.read()
        b64 = base64.b64encode(b).decode("utf-8")

        payload = {
            "model": model_name,
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": FIGURE_PROMPT},
                        {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{b64}"}},
                    ],
                }
            ],
            "temperature": 0.1,
        }
        headers = {}
        if api_key:
            headers["Authorization"] = f"Bearer {api_key}"

        async with httpx.AsyncClient(timeout=120) as client:
            r = await client.post(api_url, json=payload, headers=headers)
        r.raise_for_status()
        data = r.json()
        content = data["choices"][0]["message"]["content"]
        return json.loads(content)  # → FigureAnalysis dict
    except Exception as e:
        print(f"[WARN] Qwen-VL failed: {e}")
        return None





async def _analyze_with_openai(...):
    # 여기만 OpenAI 스타일 payload로 구현
    ...



async def enrich_items_with_mm(parsed_files, backend, api_url, model_name, api_key=None):
    if not backend:
        return parsed_files

    tasks = []

    for item in parsed_files:
        imgs = item.get("extracted_images") or []
        # 여기서 사이즈로 로고 필터링 + 상위 6개 선택 등은 그대로
        selected = ...  

        for path in selected:
            tasks.append((item, path))

    async def worker(itm, path):
        analysis = await analyze_figure_image(path, backend, api_url, model_name, api_key)
        if not analysis:
            return
        mm_list = itm.setdefault("mm_summaries", [])
        mm_list.append({
            "image_path": path,
            "analysis": analysis,
        })

    await asyncio.gather(*(worker(itm, p) for itm, p in tasks))
    return parsed_files













def _walk_odl_json(node, acc, page_hint=None):
    """
    OpenDataLoader JSON을 재귀적으로 돌면서
    headings/paragraphs/lists/tables 를 acc dict에 채워 넣는 헬퍼.
    acc = {
      "headings": [ {level, text, page} ],
      "blocks":   [ {kind, text, page} ],
      "tables":   [ {page, header, rows, meta} ],
    }
    """
    if isinstance(node, list):
        for ch in node:
            _walk_odl_json(ch, acc, page_hint=page_hint)
        return

    if not isinstance(node, dict):
        return

    ntype = (node.get("type") or "").lower()
    text  = (node.get("text") or "").strip()
    page  = node.get("page") or node.get("page_number") or page_hint

    # 페이지 힌트 업데이트
    page_hint = page or page_hint

    # ---- Heading ----
    if "heading" in ntype:
        level = node.get("level") or node.get("heading_level") or 1
        if text:
            acc["headings"].append({
                "level": int(level),
                "text": text,
                "page": page_hint,
            })
            acc["blocks"].append({
                "kind": "heading",
                "level": int(level),
                "text": text,
                "page": page_hint,
            })

    # ---- Paragraph / Text / List item ----
    elif ntype in ("paragraph", "text", "list_item", "list-item", "bullet"):
        if text:
            acc["blocks"].append({
                "kind": "paragraph",
                "text": text,
                "page": page_hint,
            })

    # ---- Table ----
    elif "table" in ntype:
        # 예시: {"type":"table","rows":[["A","B"],["1","2"],...]}
        rows = node.get("rows") or node.get("table_rows") or []
        header = []
        body = []

        if isinstance(rows, list) and rows:
            # rows = list[list[str]] 라고 가정
            header = rows[0]
            body   = rows[1:] if len(rows) > 1 else []

        acc["tables"].append({
            "page": page_hint,
            "header": header,
            "rows": body,
            "meta": {
                "n_rows": len(rows),
                "n_cols": max((len(r) for r in rows), default=0),
                "raw_type": ntype,
            },
        })

    # ---- 기타 블록도 text만 있으면 blocks에 추가 ----
    else:
        if text:
            acc["blocks"].append({
                "kind": ntype or "unknown",
                "text": text,
                "page": page_hint,
            })

    # children/kids 아래도 계속 탐색
    for key in ("kids", "children", "contents", "content"):
        if key in node:
            _walk_odl_json(node[key], acc, page_hint=page_hint)





import opendataloader_pdf
import json, os, io, fitz

def parse_pdf_local(raw: bytes, filename: str, tmp_dir: str):
    base_name = os.path.splitext(filename)[0]

    # =========================
    # 1) OpenDataLoader JSON
    # =========================
    headings = []
    blocks   = []
    tables   = []

    # ODL 결과를 저장할 임시 pdf/json 경로
    tmp_pdf = os.path.join(tmp_dir, f"odl_{base_name}.pdf")
    with open(tmp_pdf, "wb") as f:
        f.write(raw)

    try:
        opendataloader_pdf.convert(
            input_path=[tmp_pdf],
            output_dir=tmp_dir,
            format=["json"],
            quiet=True,
        )

        # 출력 json 경로 추정
        json_path = os.path.join(tmp_dir, f"{os.path.basename(tmp_pdf)}.json")
        if not os.path.exists(json_path):
            alt = os.path.join(tmp_dir, f"{base_name}.json")
            if os.path.exists(alt):
                json_path = alt

        if os.path.exists(json_path):
            with open(json_path, "r", encoding="utf-8") as jf:
                data = json.load(jf)

            acc = {
                "headings": [],
                "blocks":   [],
                "tables":   [],
            }
            _walk_odl_json(data, acc)
            headings = acc["headings"]
            blocks   = acc["blocks"]
            tables   = acc["tables"]

    except Exception as e:
        print(f"[WARN] OpenDataLoader PDF 실패 (구조 정보 없음, PyMuPDF로 대체): {e}")

    # =========================
    # 2) fallback 텍스트 (ODL이 실패했거나, 너무 빈약할 때)
    # =========================
    text_chunks = []
    if blocks:
        # blocks를 페이지/순서대로 묶어서 적당한 길이로 chunking
        cur = []
        cur_len = 0
        for b in blocks:
            t = b.get("text","").strip()
            if not t:
                continue
            # heading이면 앞에 ### 붙여서 구분해 주는 것도 가능
            if b["kind"] == "heading":
                t = f"[H{b.get('level',1)}] {t}"
            if cur_len + len(t) > 3000 and cur:
                text_chunks.append("\n\n".join(cur))
                cur = [t]
                cur_len = len(t)
            else:
                cur.append(t)
                cur_len += len(t)
        if cur:
            text_chunks.append("\n\n".join(cur))

    # 그래도 아무것도 없으면 PyMuPDF로 텍스트만 추출
    if not text_chunks:
        with fitz.open(stream=raw, filetype="pdf") as doc:
            for pno in range(len(doc)):
                page = doc[pno]
                txt = page.get_text("text")
                if txt and txt.strip():
                    text_chunks.append(f"[Page {pno+1}]\n{txt.strip()}")

    # =========================
    # 3) 이미지 추출 (기존 PyMuPDF 로직 재사용)
    # =========================
    images = _extract_images_from_pdf(raw, filename, tmp_dir)

    return {
        "type": "pdf_doc",
        "filename": filename,
        "text_chunks": text_chunks[:120],
        "extracted_images": images,
        # 새 필드들
        "headings": headings,
        "tables": tables,   # ODL 기반 table 구조
    }



